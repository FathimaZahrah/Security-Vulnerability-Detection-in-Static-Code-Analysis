import streamlit as st
import spacy
from pprint import pprint
import ast
import os
import sys
import subprocess
from colorama import Fore, Style

# Initialize spaCy model
nlp = spacy.load("en_core_web_sm")

class SQLInjectionDetector(ast.NodeVisitor):
    def __init__(self):
        self.vulnerabilities = {}
        self.user_inputs = set()
        self.data_flow = {}

    def visit_FunctionDef(self, node):
        self.current_function = node.name
        self.generic_visit(node)

    def visit_Assign(self, node):
        if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Attribute):
            if node.value.func.attr in {'get', 'post', 'args', 'form'}:
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        self.user_inputs.add(target.id)
                        self.data_flow[target.id] = node.value.func.attr
        else:
            self.track_data_flow(node)
        self.generic_visit(node)

    def visit_AugAssign(self, node):
        self.track_data_flow(node)
        self.generic_visit(node)

    def visit_Call(self, node):
        if isinstance(node.func, ast.Attribute) and node.func.attr in {'execute', 'executemany'}:
            self.check_for_vulnerability(node)
        self.generic_visit(node)

    def track_data_flow(self, node):
        if isinstance(node, ast.Assign):
            targets = node.targets
            value = node.value
        elif isinstance(node, ast.AugAssign):
            targets = [node.target]
            value = node.value
        else:
            return
        
        for target in targets:
            if isinstance(target, ast.Name):
                if isinstance(value, ast.Name) and value.id in self.user_inputs:
                    self.data_flow[target.id] = value.id
                elif isinstance(value, ast.BinOp) and (self.is_user_input(value.left) or self.is_user_input(value.right)):
                    self.data_flow[target.id] = 'user_input'

    def check_for_vulnerability(self, node):
        for arg in node.args:
            if self.is_vulnerable(arg):
                lineno = node.lineno
                query = self.extract_query(arg)
                if lineno not in self.vulnerabilities:
                    self.vulnerabilities[lineno] = []
                self.vulnerabilities[lineno].append(query)

    def is_vulnerable(self, node):
        if isinstance(node, ast.BinOp) and isinstance(node.op, ast.Add):
            return self.is_user_input(node.left) or self.is_user_input(node.right)
        elif isinstance(node, ast.Name):
            return node.id in self.user_inputs or node.id in self.data_flow
        return False

    def is_user_input(self, node):
        if isinstance(node, ast.Name):
            return node.id in self.user_inputs or node.id in self.data_flow
        elif isinstance(node, ast.BinOp):
            return self.is_user_input(node.left) or self.is_user_input(node.right)
        return False

    def extract_query(self, node):
        if isinstance(node, ast.Str):
            return node.s
        elif isinstance(node, ast.BinOp):
            if isinstance(node.left, ast.Str):
                return node.left.s
            elif isinstance(node.right, ast.Str):
                return node.right.s
        return ""

def display_vulnerabilities(vulnerabilities):
    if not vulnerabilities:
        st.success("No exploitable SQL injection vulnerabilities found.")
        return
    
    st.warning("Potential SQL injection vulnerabilities detected:")
    for line, queries in vulnerabilities.items():
        st.error(f"Line {line}:")


def generate_fault_data():
    payloads = [
        "' OR '1'='1",
        "'; DROP TABLE users; --",
        "' UNION SELECT NULL, NULL, NULL, NULL; --",
        "' OR 'x'='x",
        "' OR 1=1--",
        "1 OR 1=1",
        "1 UNION SELECT 1,2,3 --",
        "1 AND 1=1",
        "' OR 'a'='a",
        "' UNION SELECT username, password FROM users --",
        "' AND 'a'='a",
        "'; WAITFOR DELAY '0:0:5' --",
        "'; SLEEP(5) --",
        "'; IF (1=1) SELECT 'A' ELSE SELECT 'B' --",
        "' OR 1=1; --",
        "'; --",
        "' /*",
        "'; DROP TABLE users; --",
        "'; SELECT * FROM information_schema.tables; --",
    ]
    return payloads

def inject_payload_to_code(code, payload):
    # Inject the payload into the code
    modified_code = code.replace('user_input', f'"{payload}"')
    return modified_code

def inject_fault_data(code):
    try:
        tree = ast.parse(code)
    except SyntaxError as e:
        st.error(f"Syntax error in the code provided: {e}")
        return

    detector = SQLInjectionDetector()
    detector.visit(tree)
    vulnerabilities = detector.vulnerabilities
    if vulnerabilities:
        display_vulnerabilities(vulnerabilities)
        payloads = generate_fault_data()
        activated_vulnerabilities = set()
        syntax_error_lines = set()

        for payload in payloads:
            modified_code = inject_payload_to_code(code, payload)
            injected_file_path = "injected_temp.py"
            with open(injected_file_path, "w") as f:
                f.write(modified_code)

            # Execute the injected code and check for vulnerability activation
            try:
                new_activated_vulnerabilities = run_injected_code(injected_file_path, detector.vulnerabilities, payload)
                activated_vulnerabilities.update(new_activated_vulnerabilities)
            except SyntaxError as e:
                syntax_error_lines.add(e.lineno)
            st.write("Modified Code with Injected Payload:")
            st.code(modified_code, language='python')

        generate_final_report(activated_vulnerabilities, vulnerabilities, syntax_error_lines)
    return vulnerabilities

def run_injected_code(file_path, vulnerabilities, payload):
    # Run the injected code file and capture output
    try:
        result = subprocess.run([sys.executable, file_path], capture_output=True, text=True)
        output = result.stdout + result.stderr
    except subprocess.CalledProcessError as e:
        raise SyntaxError(e.output)
    except Exception as e:
        return set()

    # Check if the payload had any effect
    activated_vulnerabilities = set()
    for line, queries in vulnerabilities.items():
        for query in queries:
            if query in output:
                activated_vulnerabilities.add(line)
                break

    return activated_vulnerabilities

def generate_final_report(activated_vulnerabilities, vulnerabilities, syntax_error_lines):
    st.subheader("Vulnerability Report:")
    if activated_vulnerabilities:
        st.warning("[!] Activated Vulnerabilities:")
        for line in activated_vulnerabilities:
            st.error(f"\t- Line {line}")
    else:
        st.success("[+] No Vulnerabilities Activated")

    if syntax_error_lines:
        st.warning("[!] Payloads Causing Syntax Errors:")
        for line in syntax_error_lines:
            st.warning(f"\t- Line {line}")

# Streamlit UI
st.title("SQL Injection Detector")

text = st.text_area("Enter the code: ",height=200)
if st.button("Submit"):
    if text.strip() == "":
        st.warning("Please enter a valid input.")
    else:

        # Check for SQL injection vulnerabilities
        inject_fault_data(text)
